// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include "ui.h"
#include "../CommonData.h"
#include "../CommonLibrary.h"
#include "../CommonService.h"

struct e_timer_t
{
    uint8_t minute;
    uint8_t second;
    uint64_t startTime;
} countdownTimer, endlessTimer;

std::unordered_map<MODULE_NAME, lv_obj_t*> mapCbSettingModule = { };
std::string strikeValue = "";
JsonDocument moduleStatusMapJson;
std::pair<uint8_t, uint8_t> timerSetting = { };
uint8_t moduleCount = 0;
std::unordered_map<lv_obj_t*, void(*)(void)> mapCurrentScreen = {};
lv_obj_t* currentScreen = nullptr;

void CalculateEndlessTimer()
{
    // Get running time
    auto currentTime = MILLISEC_GET - endlessTimer.startTime;

    // Calculate the number of minutes
    // Divide the total milliseconds by 60,000 (since 1 minute = 60 seconds = 60 * 1000 milliseconds) to get the total number of full minutes
    uint8_t minute = currentTime / 60000;

    // Calculate the remaining seconds after extracting minutes
    // First, convert total_milliseconds to total seconds by dividing by 1000
    // Then, use the modulo operator (%) with 60 to find the remainder when divided by 60
    // This remainder the number of seconds that do not form a complete minute
    uint8_t second = (currentTime / 1000) % 60;

    // Calculate the remaining milliseconds after extracting seconds
    // Use the modulo operator (%) with 1000 to find the remainder when total_milliseconds is divided by 1000.
    // This remainder represents the milliseconds that do not form a complete second.
    uint16_t milli = currentTime % 1000;

    // Update endless time
    sys_host::EndlessTimeClock.SetValue(std::make_tuple(minute, second, milli));
}

void CalculateCountdownTimer()
{
    // Stop timer checking
    if ((countdownTimer.minute == 0 && countdownTimer.second == 0)
        || (sys_gui::SuccessState.GetValue() == STATE_CHECKED)
        || (sys_host::StrikeNum.GetValue() >= STRIKE_NUM_MAX)
        )
    {
        if (sys_gui::SuccessState.GetValue() != STATE_CHECKED)
        {
            CommonSendRequest(WM_STOP_ALL);
            sys_host::ModuleStatus.SetValue(false);
#ifdef _WIN64
            CommonSendRequest(WM_STOP_COMPLETE);
#endif
        }

#ifdef _WIN64
        ::Beep(BEEP_FRE, BEEP_TIMEOUT);
#else
        //Beep(BEEP_FRE, BEEP_TIMEOUT);
#endif
    }
    // Countdown timer
    else if (MILLISEC_GET - countdownTimer.startTime >= sys_host::TimeCycle.GetValue())
    {
        // Countdown
        if (countdownTimer.second > 0)
        {
            countdownTimer.second--;
        }
        else
        {
            if (countdownTimer.minute > 0)
            {
                countdownTimer.minute--;
                countdownTimer.second = 59;
            }
        }

        // Update timer time
        sys_host::TimeClock.SetValue(std::make_pair(countdownTimer.minute, countdownTimer.second));

#ifdef _WIN64
        ::Beep(BEEP_FRE, BEEP_INCREASE_DURATION);
#else
        //Beep(BEEP_FRE, BEEP_INCREASE_DURATION);
#endif

        // Update countdown timer
        countdownTimer.startTime = MILLISEC_GET;
    }
}

void Init()
{
    // Brightness
    sys_gui::Brightness.SetValue(100);
    lv_slider_set_value(ui_sldBrightness, sys_gui::Brightness.GetValue(), LV_ANIM_OFF);

    // Map module name with checkbox
    mapCbSettingModule = {
        { MODULE_NAME::Wires             , ui_cbSettingModule1      },
        { MODULE_NAME::TheButton         , ui_cbSettingModule2      },
        { MODULE_NAME::Keypads           , ui_cbSettingModule3      },
        { MODULE_NAME::SimonSays         , ui_cbSettingModule4      },
        { MODULE_NAME::WhosOnFirst       , ui_cbSettingModule5      },
        { MODULE_NAME::Memory            , ui_cbSettingModule6      },
        { MODULE_NAME::MorseCode         , ui_cbSettingModule7      },
        { MODULE_NAME::ComplicatedWires  , ui_cbSettingModule8      },
        { MODULE_NAME::WireSequences     , ui_cbSettingModule9      },
        { MODULE_NAME::Mazes             , ui_cbSettingModule10     },
        { MODULE_NAME::Passwords         , ui_cbSettingModule11     },
        { MODULE_NAME::VentingGas        , ui_cbSettingNeedyModule1 },
        { MODULE_NAME::CapacitorDischarge, ui_cbSettingNeedyModule2 },
        { MODULE_NAME::Knobs             , ui_cbSettingNeedyModule3 },
    };

    // Set current screen
    currentScreen = ui_Main;

    // The map of current screen init function to be call after clicking Back in Score screen
    mapCurrentScreen = {
        { ui_Main, &ui_Main_screen_init },
        { ui_Result, &ui_Result_screen_init },
    };

#ifdef _WIN64
    // Uncheck Wires module
    lv_obj_remove_state(ui_cbSettingModule1, LV_STATE_CHECKED);
#endif
}

void AutoUpdate()
{
    if (sys_host::ModuleStatus.GetValue())
    {
        CalculateEndlessTimer();
        CalculateCountdownTimer();
    }

    if (sys_host::EndlessTimeClock.GetState())
    {
        auto time = sys_host::EndlessTimeClock.GetValue();
        lv_label_set_text_fmt(ui_lblEndlessTimer, "%02d:%02d:%003d", std::get<MINUTE_POS>(time), std::get<SECOND_POS>(time), std::get<MILLIS_POS>(time));
    }

    if (sys_host::TimeClock.GetState())
    {
        auto time = sys_host::TimeClock.GetValue();
        lv_label_set_text_fmt(ui_lblTimer, "%02d:%02d", std::get<MINUTE_POS>(time), std::get<SECOND_POS>(time));
    }

    if (sys_host::StrikeState.GetState())
    {
        auto strikeNum = sys_host::StrikeNum.GetValue();
        if ((strikeNum > 0) && (strikeNum < STRIKE_NUM_MAX))
        {
            strikeValue += 'x';
            lv_label_set_text(ui_lblStrike, strikeValue.c_str());

#ifdef _WIN64
            sys_host::StrikeState.ResetState();
#endif
        }
    }

    if (sys_gui::SuccessState.GetState())
    {
        if (sys_gui::SuccessState.GetValue() != INCORRECT)
        {
            lv_obj_clear_flag(ui_imgResult, LV_OBJ_FLAG_HIDDEN);

            if (sys_gui::SuccessState.GetValue() == STATE_UNCHECK)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_DISABLED);
            }
            else if (sys_gui::SuccessState.GetValue() == STATE_CHECKED)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_CHECKED);
            }

            // Change to result screen
            _ui_screen_change(&ui_Result, LV_SCR_LOAD_ANIM_OVER_BOTTOM, 500, 0, &ui_Result_screen_init);
            currentScreen = ui_Result;
        }

#ifdef _WIN64
        sys_gui::SuccessState.ResetState();
#endif
    }
}

void OnBrightnessChange(lv_event_t* e)
{
    sys_gui::Brightness.SetValue(lv_slider_get_value(ui_sldBrightness));
}

void Login_OnTextAreaEdit(lv_event_t* e)
{
    // Get text
    std::string text(lv_textarea_get_text(ui_TextArea));

    if (text.length() == lv_textarea_get_max_length(ui_TextArea))
    {
        // Correct verify code
        if (text == VERIFY_CODE)
        {
            // Change green background
            lv_obj_set_style_bg_color(ui_TextArea, lv_color_hex(COLOR_GREEN), LV_PART_MAIN | LV_STATE_DEFAULT);

            // Press OK
            if (lv_event_get_code(e) == LV_EVENT_READY)
            {
                // Change to main screen
                _ui_screen_change(&ui_ModuleSelect, LV_SCR_LOAD_ANIM_MOVE_LEFT, 100, 0, &ui_ModuleSelect_screen_init);
            }
        }
        // Incorrect verify code
        else
        {
            // Change red background
            lv_obj_set_style_bg_color(ui_TextArea, lv_color_hex(COLOR_RED), LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }
    else
    {
        // Change default background
        lv_obj_set_style_bg_color(ui_TextArea, lv_color_hex(COLOR_WHITE), LV_PART_MAIN | LV_STATE_DEFAULT);
    }
}

void ModuleSelect_OnButtonNextClick(lv_event_t* e)
{
    auto moduleStatusMap = sys_gui::ModuleStatusMap.GetValue();

    // Clear module status map
    moduleStatusMap.clear();

    for (const auto& cbSettingModule : mapCbSettingModule)
    {
        auto moduleEnum = cbSettingModule.first;
        auto moduleName = map_MODULE_NAME[moduleEnum];

        // Set module status map
        if (lv_obj_get_state(cbSettingModule.second) == STATE_CHECKED)
        {
            moduleStatusMap.insert(std::make_pair(moduleName, MODULE_STATUS::ON));
            moduleStatusMapJson[(uint8_t)moduleEnum] = (uint8_t)MODULE_STATUS::ON;

            // Update module count
            moduleCount++;
        }
        else if (lv_obj_get_state(cbSettingModule.second) == STATE_UNCHECK)
        {
            moduleStatusMap.insert(std::make_pair(moduleName, MODULE_STATUS::OFF));
            moduleStatusMapJson[(uint8_t)moduleEnum] = (uint8_t)MODULE_STATUS::OFF;
        }
    }

    // Update module status map
    sys_gui::ModuleStatusMap.SetValue(moduleStatusMap);
}

void TimerSelect_OnButtonNextClick(lv_event_t* e)
{
    char bufMinute[3] = { 0 }, bufSecond[3] = { 0 };

    // Get time value
    lv_roller_get_selected_str(ui_rlSettingMinute, bufMinute, sizeof(bufMinute));
    lv_roller_get_selected_str(ui_rlSettingSecond, bufSecond, sizeof(bufSecond));

    // Update timer time
    sys_host::TimeClock.SetValue(std::make_pair(std::stoi(bufMinute), std::stoi(bufSecond)));

    // Update timer setting
    timerSetting = std::make_pair(std::stoi(bufMinute), std::stoi(bufSecond));

    // Update countdown timer
    countdownTimer.minute = std::stoi(bufMinute);
    countdownTimer.second = std::stoi(bufSecond);
}

void Main_OnButtonPlayClick(lv_event_t* e)
{
    // Start Host Timer
    sys_host::ModuleStatus.SetValue(true);

    // Set start time from system time
    endlessTimer.startTime = MILLISEC_GET;
    countdownTimer.startTime = MILLISEC_GET;

    // Send module status to Transporter
    CommonSendRequestWithData(WM_SET_CLIENTSTATE, moduleStatusMapJson);
}

void Score_OnRollerOrderChange(lv_event_t* e)
{
    uint32_t index = lv_roller_get_selected(ui_rlScoreOrder);

    lv_roller_set_selected(ui_rlScoreModuleNum, index, LV_ANIM_ON);
    lv_roller_set_selected(ui_rlScoreCompletionTime, index, LV_ANIM_ON);
    lv_roller_set_selected(ui_rlScoreResult, index, LV_ANIM_ON);
}

void Score_OnClickBack(lv_event_t* e)
{
    // Change to current screen
    _ui_screen_change(&currentScreen, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 100, 0, mapCurrentScreen[currentScreen]);
}

void Main_OnLabelStrikeClick(lv_event_t* e)
{
#ifdef _WIN64
    if (e->current_target == ui_lblStrike)
    {
        // Change to result screen
        _ui_screen_change(&ui_Result, LV_SCR_LOAD_ANIM_OVER_BOTTOM, 500, 0, &ui_Result_screen_init);
        currentScreen = ui_Main;

        // Random result
        sys_gui::SuccessState.SetValue(RandomRange(STATE_UNCHECK, STATE_CHECKED + 1));
    }
#endif
}

void Score_OnLoaded(lv_event_t* e)
{
#ifdef _WIN64

#else

#endif
}

void OrderPlay_OnLoaded(lv_event_t* e)
{
    // Your code here
}

void Result_OnLoaded(lv_event_t* e)
{
    auto endlessTimer = sys_host::EndlessTimeClock.GetValue();
    auto coundownTimer = sys_host::TimeClock.GetValue();

    /* 1. Bomb configuration */
    lv_label_set_text_fmt(ui_lblTimerSetting, "%02d:%02d", timerSetting.first, timerSetting.second);
    lv_label_set_text_fmt(ui_lblModuleCount, "%d Modules", moduleCount);
    lv_label_set_text_fmt(ui_lblStrikeCount, "%d Strikes", sys_host::StrikeNum.GetValue());

    /* 2. Result */
    if (sys_gui::SuccessState.GetValue() == STATE_CHECKED)
    {
        lv_image_set_src(ui_imgResult, &ui_img_stamp_defused_png);

    }
    else if (sys_gui::SuccessState.GetValue() == STATE_UNCHECK)
    {
        lv_image_set_src(ui_imgResult, &ui_img_stamp_exploded_png);
    }

    lv_label_set_text_fmt(ui_lblTimeRemain, "%02d:%02d", coundownTimer.first, coundownTimer.second);
    lv_label_set_text_fmt(ui_lblTimeElapse, "%02d:%02d:%003d", std::get<MINUTE_POS>(endlessTimer), std::get<SECOND_POS>(endlessTimer), std::get<MILLIS_POS>(endlessTimer));

    if (sys_gui::SuccessState.GetValue() == STATE_UNCHECK)
    {
        lv_obj_remove_flag(ui_lblExpCauseTitle, LV_OBJ_FLAG_HIDDEN);
        lv_obj_remove_flag(ui_lblExpCause, LV_OBJ_FLAG_HIDDEN);
        lv_label_set_text_fmt(ui_lblExpCause, "%s", sys_host::ClientName.GetValue().c_str());
    }
}
