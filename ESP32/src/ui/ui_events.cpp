// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#ifdef _WIN64
#include <iostream>
#endif
#include <algorithm>
#include "ui.h"
#include "../CommonData.h"
#include "../CommonLibrary.h"
#include "../CommonService.h"

struct chart_info_t {
    lv_obj_t* chart;
    lv_chart_series_t* series;
    std::vector<std::pair<int32_t, int32_t>> listData;

    chart_info_t(int32_t size, lv_obj_t* chart, uint32_t seriesColor)
    {
        this->chart = chart;
        this->series = lv_chart_add_series(this->chart, lv_color_hex(seriesColor), LV_CHART_AXIS_PRIMARY_Y);

        // Set chart properties
        lv_obj_set_style_line_width(this->chart, 0, LV_PART_ITEMS); // Remove the lines
        lv_chart_set_range(this->chart, LV_CHART_AXIS_PRIMARY_X, MIN_POINT_NUM, size);
        lv_chart_set_range(this->chart, LV_CHART_AXIS_PRIMARY_Y, MIN_POINT_NUM, size);
        lv_chart_set_div_line_count(this->chart, 0, 0);
    }

    void SetChartData()
    {
        for (const auto& item : this->listData)
        {
            lv_chart_set_next_value2(this->chart, this->series, std::get<0>(item), std::get<1>(item));
        }
        lv_chart_set_next_value2(this->chart, this->series, std::get<0>(this->listData.back()), std::get<1>(this->listData.back()));

        lv_chart_refresh(this->chart);
    }

    void SetPointMulti(std::vector<std::pair<int32_t, int32_t>> listCord)
    {
        this->listData = listCord;

        // Clear all point
        lv_chart_set_point_count(this->chart, 0);
        lv_chart_set_point_count(this->chart, POINT_CAPACITY);

        // Set new point
        SetChartData();
    }
};

chart_info_t* chartGrid = nullptr;
chart_info_t* chartIndicator = nullptr;
chart_info_t* chartNavigator = nullptr;
chart_info_t* chartMover = nullptr;

std::unordered_map<lv_obj_t*, MOVE_TYPE> mapButtonMoveType = { };

std::vector<lv_image_dsc_t> listChartBgImg = {
    ui_img_maze0_png,
    ui_img_maze1_png,
    ui_img_maze2_png,
    ui_img_maze3_png,
    ui_img_maze4_png,
    ui_img_maze5_png,
    ui_img_maze6_png,
    ui_img_maze7_png,
    ui_img_maze8_png,
};

void Init()
{
    // Brightness
    sys_gui::Brightness.SetValue(100);
    lv_slider_set_value(ui_sldBrightness, sys_gui::Brightness.GetValue(), LV_ANIM_OFF);

    // Hide debug image background
    DebugState.SetValue(INCORRECT);
    lv_obj_add_flag(ui_chartBgImg, LV_OBJ_FLAG_HIDDEN);

    // Map move type to button
    mapButtonMoveType = {
        { ui_btnLeft, MOVE_TYPE::LEFT },
        { ui_btnRight, MOVE_TYPE::RIGHT },
        { ui_btnUp, MOVE_TYPE::UP },
        { ui_btnDown, MOVE_TYPE::DOWN },
    };

    // Init chart
    chartGrid = new chart_info_t(MAX_POINT_NUM, ui_chartGrid, GRID_POINT_COLOR);
    chartIndicator = new chart_info_t(MAX_POINT_NUM, ui_chartIndicator, 0);
    chartNavigator = new chart_info_t(MAX_POINT_NUM, ui_chartNavigator, 0);
    chartMover = new chart_info_t(MAX_POINT_NUM, ui_chartMover, MOVER_COLOR);

    // Fill grid point
    int32_t x = 0, y = 0;
    for (x = MIN_POINT_NUM; x <= MAX_POINT_NUM; x++)
    {
        for (y = MIN_POINT_NUM; y <= MAX_POINT_NUM; y++)
        {
            chartGrid->listData.push_back(std::make_pair(x, y));
        }
    }
    chartGrid->SetChartData();

    // Select random maze type
    MazeIndex.SetValue(RandomRange(0, MAZE_TYPE_NUM));
    chartIndicator->SetPointMulti(listMazeType[MazeIndex.GetValue()].first);

    // Random navigator position
    NavigatorPosition.SetValue(std::make_pair((int32_t)RandomRange(1, MAX_POINT_NUM + 1), (int32_t)RandomRange(1, MAX_POINT_NUM + 1)));
    chartNavigator->SetPointMulti({ NavigatorPosition.GetValue() });

    // Random mover position, must not same with navigation position
    std::pair<int32_t, int32_t> moverPos = std::make_pair(0, 0);
    auto navigationPos = NavigatorPosition.GetValue();

    do
    {
        moverPos = std::make_pair((int32_t)RandomRange(1, MAX_POINT_NUM + 1), (int32_t)RandomRange(1, MAX_POINT_NUM + 1));
    } while (moverPos == navigationPos);

    MoverPosition.SetValue(moverPos);
    chartMover->SetPointMulti({ moverPos });

#ifdef _WIN64
    debug_println("Maze index: " + std::to_string(MazeIndex.GetValue() + 1));
#endif
}

void AutoUpdate()
{
    if (MoverPosition.GetState())
    {
        chartMover->SetPointMulti({ MoverPosition.GetValue() });
    }

    if (DebugState.GetState())
    {
        if (DebugState.GetValue() != INCORRECT)
        {
            if (DebugState.GetValue() == DEBUG_SHOW)
            {
                lv_obj_remove_flag(ui_chartBgImg, LV_OBJ_FLAG_HIDDEN);

                // Set chart background
                lv_obj_set_style_bg_image_src(ui_chartBgImg, &listChartBgImg[MazeIndex.GetValue()], LV_PART_MAIN | LV_STATE_DEFAULT);
            }
            else if (DebugState.GetValue() == DEBUG_HIDE)
            {
                lv_obj_add_flag(ui_chartBgImg, LV_OBJ_FLAG_HIDDEN);
            }
        }
    }

    if (sys_gui::SuccessState.GetState()) {
        if (sys_gui::SuccessState.GetValue() != INCORRECT)
        {
            lv_obj_clear_flag(ui_imgResult, LV_OBJ_FLAG_HIDDEN);

            if (sys_gui::SuccessState.GetValue() == STATE_UNCHECK)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_DISABLED);
            }
            else if (sys_gui::SuccessState.GetValue() == STATE_CHECKED)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_CHECKED);
            }
        }
    }
}

void OnBrightnessChange(lv_event_t* e)
{
    sys_gui::Brightness.SetValue(lv_slider_get_value(ui_sldBrightness));

#ifdef _WIN64
    if (lv_slider_get_value(ui_sldBrightness) >= 255)
    {
        DebugState.SetValue(DEBUG_SHOW);
    }
    else if (lv_slider_get_value(ui_sldBrightness) <= 10)
    {
        DebugState.SetValue(DEBUG_HIDE);
    }
    else
    {
        DebugState.SetValue(INCORRECT);
    }
#endif
}

void OnButtonClick(lv_event_t* e)
{
    auto button = (lv_obj_t*)e->current_target;
    auto moverPos = MoverPosition.GetValue();
    auto navigatorPos = NavigatorPosition.GetValue();
    auto validMove = CheckValidMoveDirection(moverPos.first, moverPos.second, mapButtonMoveType[button]);

    // Wrong move direction
    if (!validMove)
    {
#ifndef UNIT_TEST
        // Send error to Host
        CommonSendRequest(WM_STRIKESTATE_SET);
#endif

        return;
    }

    // Calculate new mover position
    if (button == ui_btnLeft)
    {
        if (moverPos.first > MIN_POINT_NUM)
        {
            moverPos.first -= 1;
        }
    }
    else if (button == ui_btnRight)
    {
        if (moverPos.first < MAX_POINT_NUM)
        {
            moverPos.first += 1;
        }
    }
    else if (button == ui_btnUp)
    {
        if (moverPos.second < MAX_POINT_NUM)
        {
            moverPos.second += 1;
        }
    }
    else if (button == ui_btnDown)
    {
        if (moverPos.second > MIN_POINT_NUM)
        {
            moverPos.second -= 1;
        }
    }

    // Update mover position
    MoverPosition.SetValue(moverPos);

    // Mover and navigator position are same
    if (moverPos == navigatorPos)
    {
        sys_gui::SuccessState.SetValue(STATE_CHECKED);

#ifndef UNIT_TEST
        // Send success to Host
        JsonDocument jsonDocIn;
#ifdef _WIN64
        jsonDocIn["module"] = CLIENT_NAME_FOR_JSON;
#else
        jsonDocIn["module"] = CLIENT_NAME;
#endif
        CommonSendRequestWithData(WM_SUCCESSSTATE_SET, jsonDocIn);
#endif
    }
}
