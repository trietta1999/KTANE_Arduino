// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#ifdef _WIN64
#include <iostream>
#endif
#include <algorithm>
#include "ui.h"
#include "../CommonData.h"
#include "../CommonLibrary.h"
#include "../CommonService.h"

#ifdef UNIT_TEST
std::tuple<TEXT_TYPE, std::string> ut_textInfo;
#endif

struct chart_info_t {
    lv_obj_t* chart;
    lv_chart_series_t* series;
    std::vector<int32_t> listData;

    chart_info_t(uint8_t size, lv_obj_t* chart, uint32_t seriesColor)
    {
        this->listData.resize(size);
        this->chart = chart;
        this->series = lv_chart_add_series(this->chart, lv_color_hex(seriesColor), LV_CHART_AXIS_PRIMARY_Y);
    }

    void SetChartData()
    {
        lv_chart_set_ext_y_array(this->chart, this->series, this->listData.data());
        lv_chart_refresh(this->chart);
    }

    void SetActive(uint8_t index)
    {
        // All data off
        std::fill(this->listData.begin(), this->listData.end(), CHANNEL_OFF);

        // Set active
        listData[index] = CHANNEL_ACTIVE;
        SetChartData();
    }
};

uint8_t currentRadioChannel = 0;

chart_info_t* chartMorseCodeInfo = nullptr;
chart_info_t* chartMorseCodeActiveInfo = nullptr;
chart_info_t* chartRadioInfo = nullptr;

void CreateBlinkLamp()
{
    static uint8_t index = 0;
    static bool lampState = true;
    static bool lampEnable = true;
    static lv_timer_t* timerLampBlink = lv_timer_create([](lv_timer_t* timer) {
        if (sys_gui::SuccessState.GetValue() != INCORRECT)
        {
            // Delete timer
            lv_timer_del(timer);
            timer = nullptr;
            timerLampBlink = nullptr;

            // Turn off lamp
            lv_obj_set_style_bg_color(ui_lblLamp, lv_color_hex(COLOR_LAMP_OFF), LV_PART_MAIN | LV_STATE_DEFAULT);

            // Exit timer
            return;
        }

        // Get symbol
        auto symbol = chartMorseCodeInfo->listData[index];

        // Dot symbol
        if (symbol == DOT_LEVEL)
        {
            lv_timer_set_period(timer, DOT_SLEEP);
            lampEnable = true;
        }
        // Dash symbol
        else if (symbol == DASH_LEVEL)
        {
            lv_timer_set_period(timer, DASH_SLEEP);
            lampEnable = true;
        }
        // Empty symbol
        else if (symbol == SPACE_LEVEL)
        {
            // Quick bypass
            lv_timer_set_period(timer, SPACE_SLEEP);

            // End of letter
            if ((index + 1) % MAX_MORSE_SYMBOL == 0)
            {
                lv_obj_set_style_bg_color(ui_lblLamp, lv_color_hex(COLOR_LAMP_OFF), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_timer_set_period(timer, LETTER_SLEEP);
            }

            lampEnable = false;
        }

        if (lampEnable)
        {
            // Turn on lamp
            if (lampState)
            {
                lv_obj_set_style_bg_color(ui_lblLamp, lv_color_hex(COLOR_LAMP_ON), LV_PART_MAIN | LV_STATE_DEFAULT);

                // Set active morse code position
                chartMorseCodeActiveInfo->SetActive(index);

                // Move to next active morse code position
                index++;
            }
            // Turn off lamp
            else
            {
                lv_obj_set_style_bg_color(ui_lblLamp, lv_color_hex(COLOR_LAMP_OFF), LV_PART_MAIN | LV_STATE_DEFAULT);
                lv_timer_set_period(timer, SYMBOL_SLEEP);
            }

            // Toggle lamp
            lampState = !lampState;
        }
        else
        {
            // Move to next active morse code position
            index++;
        }

        // End of word
        if (index >= MAX_SYMBOL)
        {
            index = 0;
            lv_timer_set_period(timer, WORD_SLEEP);
        }
        }, 0, nullptr);
}

void Init()
{
    // Brightness
    sys_gui::Brightness.SetValue(100);
    lv_slider_set_value(ui_sldBrightness, sys_gui::Brightness.GetValue(), LV_ANIM_OFF);

    // Init chart
    chartMorseCodeActiveInfo = new chart_info_t(MAX_SYMBOL, ui_chartMorseCode, COLOR_BLUE); // Active cursor - lamp blinking chart
#ifdef _WIN64
    chartMorseCodeInfo = new chart_info_t(MAX_SYMBOL, ui_chartMorseCode, COLOR_RED); // Morse code chart
#else
    auto dummyChart = lv_chart_create(ui_Main);
    lv_obj_add_flag(dummyChart, LV_OBJ_FLAG_HIDDEN);
    chartMorseCodeInfo = new chart_info_t(MAX_SYMBOL, dummyChart, COLOR_RED); // Dummy morse code chart
#endif
    chartRadioInfo = new chart_info_t(MAX_CHANNEL, ui_chartRadio, COLOR_RED); // Radio channel chart

    // Get morse code info
#ifdef UNIT_TEST
    auto textInfo = ut_textInfo;
#else
    auto textInfo = GetRandomText();
#endif
    chartMorseCodeInfo->listData = FlatMorseCodeArray(ConvertTextToMorseCode(std::get<TEXT_STR_POS>(textInfo)));

    // Set chart data
    chartMorseCodeInfo->SetChartData();

    // Set correct data
    CorrectFrequency.SetValue(mapTextFrequency[std::get<TEXT_TYPE_POS>(textInfo)]);
    CorrectWord.SetValue(std::get<TEXT_STR_POS>(textInfo));

#ifndef UNIT_TEST
    // Init radio channel
    OnButtonMoveClick(nullptr);

    // Bink lamp timer
    CreateBlinkLamp();
#endif

#ifdef _WIN64
    debug_println("Corect word: " + CorrectWord.GetValue());
    debug_println("Corect frequency: " + std::to_string(CorrectFrequency.GetValue()));
#endif
}

void AutoUpdate()
{
#ifndef UNIT_TEST
    if (sys_gui::SuccessState.GetState()) {
        if (sys_gui::SuccessState.GetValue() != INCORRECT)
        {
            lv_obj_clear_flag(ui_imgResult, LV_OBJ_FLAG_HIDDEN);

            if (sys_gui::SuccessState.GetValue() == STATE_UNCHECK)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_DISABLED);
            }
            else if (sys_gui::SuccessState.GetValue() == STATE_CHECKED)
            {
                lv_obj_add_state(ui_imgResult, LV_STATE_CHECKED);
            }
        }
    }
#endif
}

void OnBrightnessChange(lv_event_t* e)
{
    sys_gui::Brightness.SetValue(lv_slider_get_value(ui_sldBrightness));
}

void OnButtonTXClick(lv_event_t* e)
{
    if (TempFrequency.GetValue() == CorrectFrequency.GetValue())
    {
        sys_gui::SuccessState.SetValue(STATE_CHECKED);

#ifndef UNIT_TEST
        // Send success to Host
        JsonDocument jsonDocIn;
#ifdef _WIN64
        jsonDocIn["module"] = CLIENT_NAME_FOR_JSON;
#else
        jsonDocIn["module"] = CLIENT_NAME;
#endif
        CommonSendRequestWithData(WM_SUCCESSSTATE_SET, jsonDocIn);
#endif
    }
    else
    {
#ifndef UNIT_TEST
        // Send error to Host
        CommonSendRequest(WM_STRIKESTATE_SET);
#endif
    }
}

void OnButtonMoveClick(lv_event_t* e)
{
    if (e)
    {
        auto button = e->current_target;

        if (button == ui_btnMoveLeft)
        {
            if (currentRadioChannel > 0)
            {
                currentRadioChannel--;
            }
        }
        else if (button == ui_btnMoveRight)
        {
            if (currentRadioChannel < MAX_CHANNEL - 1)
            {
                currentRadioChannel++;
            }
        }
    }

    auto frequency = mapTextFrequency[(TEXT_TYPE)(currentRadioChannel + 1)];

    // Update radio channel
    chartRadioInfo->SetActive(currentRadioChannel);

    // Update frequency label
    auto frequencyStr = std::to_string(frequency);
    frequencyStr.insert(1, ".");
    lv_label_set_text_fmt(ui_lblFrequency, "%s MHz", frequencyStr.c_str());

    // Set temp frequency
    TempFrequency.SetValue(frequency);
}
